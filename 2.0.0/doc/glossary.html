<!DOCTYPE html>
<html lang="ja-JP">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Language" content="ja-JP">
  <link rel="stylesheet" type="text/css" href="../style.css">
  <link rel="icon" type="image/png" href="../rurema.png">
  <title>Ruby用語集</title>
</head>
<body>

<p>

<a href="../doc/index.html">Ruby 2.0.0 リファレンスマニュアル</a>
&gt; Ruby用語集

</p>

<h1>Ruby用語集</h1>

<h2 >A</h2>
<dl>
<dt>AWK</dt>
<dd>
<p>
エイホ(A)、ワインバーガー(W)、カーニハン(K)による
小型のスクリプト言語。
</p>
</dd>
</dl>
<h2 >B</h2>
<dl>
<dt>blade</dt>
<dd>
<p>
ml archive (<a class="external" href="http://blade.nagaokaut.ac.jp/ruby/">http://blade.nagaokaut.ac.jp/ruby/</a>)
</p>
</dd>
</dl>
<h2 >C</h2>
<dl>
<dt>Coerce</dt>
<dd>
<p>
数値の型変換を行うメソッド。数値計算のメソッドは自分の知らな
いインスタンスが引数として渡された時にはcoerce
メソッドを使って変換を行うように取り決められている。
coerceメソッドは引数として与えられた値(を変換し
た値)と自分(必要ならば変換した値)のペアを返す。
</p>
<p>
Rubyのライブラリの数値型の変換順序は
</p>
<p>
Fixnum -&gt; Bignum -&gt; Rational -&gt; Float -&gt; Complex
</p>
<p>
になっている。
</p>
</dd>
</dl>
<h2 >D</h2>
<dl>
<dt>Data</dt>
<dd>
<p>
CレベルのポインタをRubyオブジェクトとして見せるためのラッパー。
Cポインタと、mark関数、free関数から作る。Cを使ってRubyに機能
を追加しようとする人はぜひこのクラスの使い方をマスターする必
要がある。逆にいうとそういう予定のない人には用事がないクラス
でもある。
</p>
</dd>
<dt>defined?</dt>
<dd>
<p>
いろいろなもの(式)が本当に定義されているかどうか調べてくれる
演算子。定義されていなければnil、定義されてい
ればその式の種別を示す文字列を返す。defined?は
メソッドのようにみえるがRubyの文法に組み込まれた演算子で、引
数の評価を行わない。よって
</p>
<pre>
            defined? print(&quot;abc\n&quot;)
</pre>
<p>
はなにも出力しない。
</p>
</dd>
</dl>
<h2 >E</h2>
<dl>
<dt>Eiffel</dt>
<dd>
<p>
オブジェクト指向プログラミング言語。matzは昔この言語の作者の
本(Object-oriented Software Construction 邦訳「オブジェクト
指向入門」)を読んで目から鱗が落ちたらしい。その割にはRubyは
Eiffelに似ていない。似ているのはブロックがendで
終るところと、rescueという予約語だけか。
</p>
</dd>
<dt>end</dt>
<dd>
<p>
ブロック構造を終える予約語。ある統計によればRubyを最初に見た
人の33%がこれを見てPascalを連想するという(嘘)。しかし、実際
にはbeginと対にならないこの形式はPascalというよりAdaやEiffel
に近い。
</p>
<p>
RubyがCやPerlで慣れ親しんだ {}を使わなかったの
は以下の理由である
</p>
<p>
* 単文・複文問題の回避
</p>
<p>
たとえばCでは
</p>
<pre>
              if (a==b)
                 c();
</pre>
<p>
に文を追加しようとして
</p>
<pre>
              if (a==b)
                 c();
                 d();
</pre>
<p>
などとするとややこしいバグの元になる。この問題はPascalにも存
在する。
</p>
<p>
* ぶらさがりelse問題の回避
</p>
<p>
上記と類似だが、
</p>
<pre>
              if (a==b)
                 if (c==d) foo();
              else bar();
</pre>
<p>
などと書いてしまうと面倒なことになる。上のプログラムは実は
</p>
<pre>
              if (a==b) {
                 if (c==d) foo();
                 else bar();
              }
</pre>
<p>
という意味である。
</p>
<p>
* 可読性の向上
</p>
<p>
異論はあるようだが、endという単語でブロックを閉じた方がプロ
グラムが読みやすいと考えている人がいる。
</p>
<p>
* begin, caseの構文上の問題
</p>
<p>
正直言うと、matzはendという名前の変数を使おうとして痛い目に
あったことが何度かある。そこで、一度は { }を使っ
た文法にしようと検討したが、beginとcase
の文法がきれいにまとまらずに断念した。実をいうとこれが最大の
理由であったりする。
</p>
</dd>
<dt>ENV</dt>
<dd>
<p>
環境変数をアクセスするための<a href="../class/-hash.html">Hash</a>
と同様の動作をするオブジェクト。実際には特異メソッドを付加し
た<a href="../class/-object.html">Object</a>クラスのイン
スタンスである。このオブジェクトによって
環境変数を変更すると、
Rubyの子プロセスにも引き継がれる。
</p>
</dd>
</dl>
<h2 >F</h2>
<dl>
<dt>FAQ</dt>
<dt>Frequently Asked Questions</dt>
<dd>
<p>
よくある質問とその答え集。
</p>
</dd>
</dl>
<h2 >G</h2>
<dl>
<dt>goto</dt>
<dd>
<p>
Rubyにないもの。gotoがないのはそれが「あるべきでないから」ではなく、
「実装するのが面倒だったから」である。
gotoの代りはcatch/throwや例外で実現する。
</p>
</dd>
</dl>
<h2 >H</h2>
<h2 >I</h2>
<h2 >J</h2>
<dl>
<dt>JARH</dt>
<dt>Just another Ruby hacker,</dt>
<dd>
</dd>
</dl>
<h2 >K</h2>
<h2 >L</h2>
<h2 >M</h2>
<dl>
<dt>main</dt>
<dd>
<p>
トップレベルでのself。
selfがないわけにはいかないので、ただそこにある
ためだけの単なるObjectクラスのインスタンスであるが、
Objectクラスを操作するため、いくつかの特異メソッドを定義して
ある。
</p>
<p>
定義されている特異メソッド
</p>
<p>
* private
</p>
<p>
* public
</p>
<p>
* include
</p>
</dd>
<dt>matz</dt>
<dd>
<p>
Rubyの作者。まつもと ゆきひろとも言う。
<a class="external" href="http://cmail.sourceforge.jp/">http://cmail.sourceforge.jp/</a>
と4人の子供の父親でもある。
</p>
</dd>
<dt>ミックスイン</dt>
<dt>Mix-in</dt>
<dd>
<p>
アイスクリームにいろんなものをまぜて新しい味を作ること。転じ
てモジュールをクラスに混ぜて機能を追加
すること。継承を参照。
</p>
<p>
Rubyでは多重継承を採用せず、is-aの関係のための継承と、機能の
共有のためのMix-inを用意している。これは多重継承を濫用すると
関係が混乱するというmatzの信念のためである。
</p>
</dd>
</dl>
<h2 >N</h2>
<h2 >O</h2>
<h2 >P</h2>
<dl>
<dt>Perl</dt>
<dd>
<p>
何だったっけ？
</p>
</dd>
<dt>POLS</dt>
<dd>
<p>
Principle of least surprise
</p>
</dd>
<dt>Python</dt>
<dd>
<p>
Rubyのライバル。「年を経た蛇」。matzがPythonに満足していれば
Rubyは生まれなかったであろう。一番気になっているのは名前の長
さ(6文字)である。
</p>
</dd>
</dl>
<h2 >Q</h2>
<h2 >R</h2>
<dl>
<dt>RCR</dt>
<dd>
<p>
Ruby Change Request
</p>
</dd>
<dt>RD</dt>
<dd>
<p>
Ruby Document
</p>
</dd>
<dt>Ruby</dt>
<dd>
<p>
オブジェクト指向スクリプト言語。Rubyの名前は「Perlに続く
(pearlは6月の誕生石、Rubyは7月の誕生石)」という程度の意味で
名付けられた。Rubyは別に何かの略ではない。
</p>
</dd>
</dl>
<h2 >S</h2>
<dl>
<dt>Sather</dt>
<dd>
<p>
オブジェクト指向プログラミング言語。matzは
EiffelよりもSatherが好きだ。しかし、
SatherもやっぱりRubyには全然似ていない。
</p>
</dd>
<dt>self</dt>
<dd>
<p>
レシーバを参照する式。なぜ
selfかというと、メソッド
を動詞と考えるとレシーバは主語に当たり、メソッドから見ると
自分であるからという説があるが、Rubyでは深
く考えず、単にSmalltalkを真似ただけ
だ、という説が有力である。
</p>
</dd>
<dt>Smalltalk</dt>
<dd>
<p>
オブジェクト指向プログラミング言語。現在の
オブジェクト指向と
いうパラダイムの基礎を築いた言語。
</p>
</dd>
<dt>super</dt>
<dd>
<p>
オーバーライドしたメソッドから上位のメソッドを呼び出す方法。
引数を省略した時には呼び出し元のメソッドと同じ引数で呼び出さ
れる。
</p>
<p>
* 問題:
</p>
<p>
引数として与えられた変数の値を変更した場合には、
superで元の値が渡るか、変更した値が渡るか。
</p>
<pre>
              def foo(a)
                 print a
              end
              def self.foo(a)
                a=25
                super
              end
              foo(5)    # 5 or 25??
</pre>
<p>
* 答え:
</p>
<p>
変更した値(25)。古いバージョンでは 5 を返すという仕様だった。現在
はこの問題自体にあまり意味がないかも知れない。
</p>
</dd>
</dl>
<h2 >T</h2>
<dl>
<dt>Thread</dt>
<dd>
<p>
もとはThread of controlの略。一連の制御の流れのこと。Rubyでは
一つのプログラムの中に複数のスレッドが存在できる。
</p>
</dd>
</dl>
<h2 >U</h2>
<dl>
<dt>undef</dt>
<dd>
<p>
メソッドを未定義状態にすること。継承
もMix-inもクラスにメソッドを追加するこ
とだが、undefを使えばメソッドを取り除くことがで
きる。ただし、クラスの実装に必要なメソッド(メソッド内部から
呼ばれているメソッド)を外してしまうと痛い目に遭う。
</p>
</dd>
</dl>
<h2 >V</h2>
<h2 >W</h2>
<h2 >X</h2>
<h2 >Y</h2>
<h2 >Z</h2>
<h2 >あ</h2>
<dl>
<dt>浅い複製</dt>
<dt>Shallow copy</dt>
<dd>
<p>
インスタンスの浅いコピー。
フィールド内のインスタンスは、参照をコピーするだけである。
例えば、配列に浅い複製を行った場合、配列はコピーされるが
配列内の要素が参照しているオブジェクトはコピーされない。
うっかり破壊的なメソッドを使ってしまうと思わぬ所に影響が
出る恐れがあるため、気をつける必要がある。
対義語 深い複製
</p>
</dd>
<dt>イテレータ</dt>
<dt>Iterator</dt>
<dd>
<p>
ブロック付きメソッド呼び出しのこと。
ブロック付きメソッドは当初繰り返し処理を行うために作られたため、
未だにイテレータと呼ぶことがある。
繰り返しを意図したメソッドをイテレータと呼ぶのはかまわないが、
ブロック付きメソッド呼び出し全般をイテレータと呼ぶと混乱の元
になるので気を付けるように。
</p>
</dd>
<dt>インスタンス</dt>
<dt>Instance</dt>
<dd>
<p>
オブジェクトのこと。オブジェクトがある
クラスに所属することを強調する意味あいがあるらしい。オブジェ
クトなんだかインスタンスなんだか混乱してオブジェクト指向に挫
折する人は多いと聞く。
</p>
</dd>
<dt>インスタンス変数</dt>
<dt>Instance Variable</dt>
<dd>
<p>
オブジェクトに固有の変数のこと。Rubyのインスタンス変数は識別
子の直前に@をつけたものであり、メソッドの中から
しか参照できない。
</p>
</dd>
<dt>オーバーライド</dt>
<dt>Override</dt>
<dd>
<p>
再定義のこと。スーパークラスまた
はincludeしているモジュールで定義され
ているメソッドと同じ名前のメソッドを定義すること。オーバーラ
イドした上位のメソッドは
superを使って呼び出すこと
ができる。
</p>
</dd>
<dt>オブジェクト</dt>
<dt>Object</dt>
<dd>
<p>
もののこと。「愛」は多分オブジェクトではな
いが、「ラブレター」はオブジェクトである。あるものがものであ
るか、そうでないかは多分に哲学的である。この辺がオブジェクト
指向は難しいといわれる原因かも知れない。コンピュータ業界では
メモリ中の特定の空間のことをオブジェクトと呼ぶ人がいたりする
人がいる。困ったものだ。カプセル化、
抽象データ型参照。
</p>
</dd>
<dt>オブジェクト指向</dt>
<dd>
<p>
オブジェクトを基本にしたパラダイム。
英語の&quot;Object-Oriented&quot;という形容詞が、日本に来て名詞化した。
オブジェクトを考え方の中心に置けば、なんでも良いようにも思え
るが、一般的には
</p>
<p>
* 継承
</p>
<p>
* カプセル化
</p>
<p>
* ポリモルフィズム
</p>
<p>
(あるいは動的結合)
</p>
<p>
が必要らしい。
なんでも解決できる「魔法」のように考える人もいるが、世の中そ
んなに甘くない。誕生から20数年を経てようやっと実用的に使われ
るようになった…んだろうな、多分。
</p>
</dd>
<dt>オブジェクト指向設計</dt>
<dt>Object-Oriented Design</dt>
<dd>
<p>
オブジェクトを基本にしたシステム設計
</p>
</dd>
<dt>オブジェクト指向プログラミング</dt>
<dt>Object-Oriented Programming</dt>
<dd>
<p>
オブジェクトを基本にしたプログラミング。
</p>
</dd>
<dt>オブジェクト指向分析</dt>
<dt>Object-Oriented Analysis</dt>
<dd>
<p>
オブジェクトを基本にしたシステム分析。
</p>
</dd>
</dl>
<h2 >か</h2>
<dl>
<dt>カプセル化</dt>
<dt>Encapsulation</dt>
<dd>
<p>
データに対する直接的な操作はデータの型に付随する特定の手続き
(メソッドと呼ぶ)からだけ行うことにより、
内部構造や処理のアルゴリズムを外部から隠してしまうこと。
抽象データ型参照。
</p>
<p>
Rubyはインスタンス変数はメソッドからしか参照できないので、カ
プセル化が強制されているといえる。
</p>
</dd>
<dt>環境変数</dt>
<dt>Environment Variable</dt>
<dd>
<p>
親プロセスから子プロセスに対して受け渡される値。
ENVでアクセスされる。
子プロセスに渡るのは環境変数のコピーなので、子プロセスから親
プロセスに環境変数を使って情報を受け渡すことはできない。
親はなかなか子供に耳を傾けないものである。
</p>
</dd>
<dt>関数</dt>
<dt>Function</dt>
<dd>
<p>
厳密にいうとRubyに関数はない。しかし、レシーバを省略したメソッ
ド呼び出しは外見が関数に似ているし、
selfやインスタンス変数など
レシーバの情報を全く参照しない事実上の関数として働いていると
いっても良いメソッドもある。だから厳密でない言い方としてそう
いうメソッドを関数と呼ぶこともある。
</p>
<p>
そういう関数(的メソッド)は大抵レシーバを省略した形式でしか呼
び出せないように可視性がprivateに
設定してある。このようなメソッドの代表として
モジュール関数がある。
</p>
</dd>
<dt>クラスメソッド</dt>
<dt>Class Method</dt>
<dd>
<p>
クラスのメソッド。全てのクラスのクラス
<a href="../class/-class.html">Class</a>で定義されている
全てのクラスで共有されているメソッドとクラスそれぞれが固有に持っている
特異メソッドとがあるが、そんな
ことは大した問題ではない。
クラスメソッド内でのselfはクラスであるので勘違いしないように。
</p>
</dd>
<dt>グローバル変数</dt>
<dt>Global Variable</dt>
<dd>
<p>
プログラム全体から参照できる変数。危険。多用しないこと。
</p>
</dd>
<dt>継承</dt>
<dt>Inheritance</dt>
<dd>
<p>
先祖や親戚から受け継いだものに頼り切って、
自分では最低限のことしかしないこと。現実世界では嫌な奴。
転じて、あるクラスに機能を追加した新しいクラス
を作ること。継承はis-aの関係を表現するのに有効である。たとえ
ば、学生一般の性質を記述した「学生」クラスを継承して、実験に
苦しめられる「工学部生」クラスを作ることができる。is-aの関係
がなく、単に性質や機能を共有する場合にはMix-in
を使うことが望ましいとされる。
</p>
</dd>
</dl>
<h2 >さ</h2>
<dl>
<dt>再定義</dt>
<dt>Redefinition</dt>
<dd>
<p>
オーバーライドのこと。
</p>
</dd>
<dt>辞書</dt>
<dt>Dictionary</dt>
<dd>
<p>
項目からその定義を取り出すことができるもの。転じて
ハッシュの別名。オブジェクト指向の起源と
も呼べるSmalltalkにおいてハッシュに
相当するデータ構造が「辞書」と呼ばれていたせいで辞書という用
語になじんでいる一群の人々がいる。
</p>
</dd>
<dt>初期化</dt>
<dt>Initialize</dt>
<dd>
<p>
オブジェクト(あるいは「なにか」)を「使える」状態にすること。
インスタンスの初期化には
<a href="../method/-object/i/initialize.html">Object#initialize</a>
メソッドを再定義する。クラスのメソッド
<a href="../method/-class/i/new.html">Class#new</a>のデフォルトの
定義は新たに生成したインスタンスに対して、
initializeを実行する。newへの
引数はそのままinitializeに渡される。また、
newがブロックとともに呼び出された時には
initializeにそのブロックがそのまま与えられる。
</p>
<p>
ということは<a href="../method/-class/i/new.html">Class#new</a>
を再定義する必要はないはずだ。
</p>
</dd>
<dt>スクリプト</dt>
<dt>Script</dt>
<dd>
<p>
台本。転じて、インタープリタが解釈する比較的短いプログラムの
こと。もちろん中には超大作の台本もある。
</p>
</dd>
<dt>スクリプト言語</dt>
<dt>Script Language</dt>
<dd>
<p>
スクリプトに従ってバッチ処理を行うイン
タープリタのこと。人間も台本を読むという点においてスクリプト
言語である。
</p>
</dd>
<dt>即値</dt>
<dt>Immediate Value</dt>
<dd>
<p>
参照ではなく、実際の値が変数に格納さ
れるもの。Rubyの現在の実装ではFixnum、Symbolとnil/true/falseだけが即
値である。しかし、Fixnumが即値でないRubyの実装があっても構わ
ないし、モデル上全ての値がオブジェクトへの参照であると考えて
も差し支えない。
</p>
</dd>
<dt>ソート</dt>
<dt>Sort</dt>
<dd>
<p>
順番に並べ替えること。Ruby は数え上げる事ができて
(Enumerable がincludeされていて)、各要素に順序
が定義されて(&lt;=&gt; が定義されて)いれば、配列に限らずどん
な複雑なオブジェクトの集まりもソートしてくれる。
</p>
</dd>
</dl>
<h2 >た</h2>
<dl>
<dt>大域脱出</dt>
<dt>Non-Local Exit</dt>
<dd>
<p>
break, next, redo, retry, return
などのメソッドの範囲内での脱出ではなく、捕捉されない限りメソッ
ド呼び出しの階層を遡って中断するタイプのものを大域脱出と呼ぶ。
Rubyの大域脱出には、例外によるものとcatch/throwがある。
</p>
<p>
ほとんどの例外は(exitで発生するSystemExit
を含めて rescue で捕捉できるが、捕捉することに意味がない例外
(例:メモリ割当に失敗した/インタプリタそのもののバグ)は
捕捉の対象にならない。
</p>
<p>
catch/throwはthrowされると指定されたタグと同じ
タグを持つcatchまで一気にジャンプするものである。
</p>
</dd>
<dt>ダイナミックローカル変数</dt>
<dt>Dynamic Local Variable</dt>
<dd>
<p>
ローカル変数 の一種。Rubyのローカル変数はスコープが
静的に決まるためコンパイル時に変数が作成されるが、ダイナミックローカ
ル変数は、実行の都度変数が作成される。ブロックの中で初めて代入された
ローカル変数はダイナミックローカル変数となり、そのスコープはブロック
の中だけとなる。これは、Thread 毎に独立した変数を持
つためにある。
</p>
</dd>
<dt>抽象データ型</dt>
<dt>Abstract Data Type</dt>
<dd>
<p>
データの構造とそのデータに対する操作をひとまとめにしたものを
抽象データ型と呼ぶ。抽象データに対する操作は必ずその操作を経
由する必要がある。結果、データ構造は外部からは直接参照されず、
内部構造の変更が外部に悪影響を及ぼさない。このことを
カプセル化と呼ぶ。
</p>
</dd>
<dt>定数</dt>
<dt>Constant</dt>
<dd>
<p>
一度定義したら値を変えることができない変数。
でも、この定義は矛盾しているなあ。
</p>
</dd>
<dt>動的結合</dt>
<dt>Dynamic Binding</dt>
<dd>
<p>
操作の対象のデータ型に合わせて適切な手続き(メソッド)が実行時
に選択されること。プログラムの柔軟性を高める働きがある。
オブジェクト指向の要件のひとつ。
Rubyでは変数に型が無いので動的結合は必然である。
</p>
</dd>
<dt>特異クラス</dt>
<dt>Singleton Class</dt>
<dd>
<p>
ある特定のオブジェクトだけのための仮想的なクラス。
</p>
</dd>
<dt>特異メソッド</dt>
<dt>Singleton Method</dt>
<dd>
<p>
ある特定のオブジェクトにだけ定義されたメソッド。
メソッド参照。
特異メソッドは以下の場合に他のオブジェクトにも引き継がれる。
</p>
<p>
* <a href="../method/-object/i/clone.html">Object#clone</a>した場合
</p>
<p>
* サブクラスを作った場合
</p>
<p>
特異メソッドで元のクラスのメソッドをオーバーライドした場合は
もとのメソッドは super で呼び出すことができる。
</p>
</dd>
<dt>ドキュメント</dt>
<dt>Document</dt>
<dd>
<p>
matzの苦手なもの。彼は普段から「ソースがドキュメントだ。バグ
も完全に記述されている」と主張しているが、誰も受け入れない。
当り前だ。
</p>
</dd>
<dt>トップレベル</dt>
<dt>Top Level</dt>
<dd>
<p>
クラス／モジュール定義の一番外側のコンテキスト。Rubyスクリプトはトップレベルの
コンテキストから処理が始まる。
</p>
<p>
いきなり、
print &quot;on Toplevel&quot;
というスクリプトを書いたとき、print メソッドはトップレベルから呼ばれている。
</p>
<p>
トップレベルの self は main を指す。
</p>
</dd>
</dl>
<h2 >な</h2>
<h2 >は</h2>
<dl>
<dt>バイトオーダー</dt>
<dt>Byte Order</dt>
<dd>
<p>
0x01020304という4バイトデータを1,2,3,4
と配置するか、4,3,2,1と配置するかということ。前
者をビッグエンディアン、後者を
リトルエンディアンと呼ぶ。どちらが
良いかという論争は時のはじめから続いていてまだ結論が出ていない。
</p>
</dd>
<dt>破壊的</dt>
<dt>Destructive</dt>
<dd>
<p>
<a href="../method/-string/i/chop=21.html">String#chop!</a>, <a href="../method/-array/i/concat.html">Array#concat</a> などの
メソッドは、レシーバの状態を変化させるので、
「破壊的な作用をする」という。
めったにコンピュータを壊すことはない。
</p>
</dd>
<dt>ハッシュ</dt>
<dt>Hash</dt>
<dd>
<p>
Rubyにおけるキーから値へのマッピングを表すデータ構造。
連想配列とか辞書とも呼ばれる。ハッシュがハッシュ
と呼ばれるのはその実現に「ハッシュ表」と呼ばれるアルゴリズム
が使われているからである。ハッシュというのは「切り刻む」とい
う意味で、「ハッシュド・ビーフ」の「ハッシュ」である。
</p>
</dd>
<dt>パラダイム</dt>
<dt>Paradigm</dt>
<dd>
<p>
「考え方」の難しい表現。素直に分かりやすい言葉を使えばいいのに…。
</p>
</dd>
<dt>ヒアドキュメント</dt>
<dt>Here Document</dt>
<dd>
<p>
<a href="../doc/spec=2fliteral.html#here">リテラル/ヒアドキュメント (行指向文字列リテラル)</a> を参照してください。
</p>
</dd>
<dt>ビッグエンディアン</dt>
<dt>Big Endian</dt>
<dd>
<p>
アメリカ大陸原住民…はインディアン。
こっちはエンディアンで語源はスウィフトの「ガリバー旅行記」に出て来る
卵を丸い端から食べる人たちである。
当然、尖った端から食べる人たちは
リトルエンディアンである。
コンピュータ業界ではCPUなどがデータを並べる時の形式のひとつで、
ネットワーク族はビッグエンディアンを好むという。
バイトオーダー参照
</p>
</dd>
<dt>ビルトインクラス</dt>
<dt>Built-In Class</dt>
<dd>
<p>
Rubyインタプリタ組み込みでインスタンスの構造が
通常のオブジェクトと異なるクラス。
これらのクラスを継承したクラスを定義することはお勧めしない。
Rubyのビルトインクラスは <a href="../library/_builtin.html">Builtin libraries</a> に列挙されている。
</p>
</dd>
<dt>深い複製</dt>
<dt>deep copy</dt>
<dd>
<p>
インスタンスの深いコピー。
フィールド内にインスタンスがある場合、
そのインスタンス専用にメモリのコピーを行う。
例えば、配列に深い複製を行った場合、配列をコピーし、
配列内の要素が参照しているオブジェクトもすべてコピーされる。
対義語 浅い複製 shallow copy
</p>
</dd>
<dt>ブロック</dt>
<dt>Block</dt>
<dd>
<p>
ループを構成したり、家や塀を建てたり、人を殴ったりするもの。
</p>
</dd>
<dt>ブロック付きメソッド呼び出し</dt>
<dd>
<p>
コードの集まり(ブロック)を受け取ることのできるメソッドを
ブロック付きメソッド呼び出しと呼ぶ。
</p>
<p>
ブロック付きメソッドの中では yield を使って
ブロックを実行することができる。
</p>
<p>
当然のことながら、与えられたブロックをどのように処理するかは
メソッド側に委ねられている。ので、内部でブロックを評価しない
メソッドにブロックを与えてもなにも起きない。エラーも起きない。
</p>
</dd>
<dt>ブロック引数</dt>
<dt>Block argument</dt>
<dd>
<p>
メソッド定義時などに使用する &amp;block などのこと。
</p>
</dd>
<dt>ブロックパラメータ</dt>
<dt>Block parameter</dt>
<dd>
<p>
ブロックに渡すパラメータのこと。
</p>
</dd>
<dt>変数</dt>
<dt>Variable</dt>
<dd>
<p>
オブジェクトにつける名札。Rubyの変数には
グローバル変数、ローカル変数、インスタンス変数がある。
それと定数は値を変えることができないので、変数ではないが、
名札であるという点においては変数と同じである。
</p>
</dd>
<dt>ポリモルフィズム</dt>
<dt>多態, Polymorphism</dt>
<dd>
<p>
対象になるオブジェクトによって実際の操作が決定されること。
Rubyではレシーバのオブジェクトに応じ
てメソッドが選択されることによって実現されている。
</p>
<p>
* 例
</p>
<pre>
              obj = &quot;abc&quot;
              print obj.length, &quot;\n&quot;          # =&gt; 3
              obj = [1,2,3,4]
              print obj.length, &quot;\n&quot;          # =&gt; 4
</pre>
</dd>
</dl>
<h2 >ま</h2>
<dl>
<dt>モジュール関数</dt>
<dt>Module Function</dt>
<dd>
<p>
関数のように用いられるメソッドの中で、
モジュールのメソッドとしても、特異メソッドとしても定義されて
いるものはモジュール関数と呼ばれる。例えば
<a href="../class/-math.html">Math</a>モジュールのほとんどのメソッドは
モジュール関数である。これらのメソッドは、例えば
</p>
<p>
Math.sqrt(2)
</p>
<p>
という形式でも
</p>
<p>
include Math
sqrt(2)
</p>
<p>
という形式でも使えて便利である。
</p>
</dd>
<dt>メソッド</dt>
<dt>Method</dt>
<dd>
<p>
オブジェクトに対する操作。操作対象のオ
ブジェクト(レシーバ)は self で参照できる。
Rubyの場合ビルトインクラスのオブジェクトを除けば、
オブジェクトの構造は動的に決まるので、
あるオブジェクトの性質はそのオブジェクトに定義されているメソッド
によって決定される。
</p>
</dd>
</dl>
<h2 >や</h2>
<h2 >ら</h2>
<dl>
<dt>リトルエンディアン</dt>
<dt>Little Endian</dt>
<dd>
<p>
最初10人いて段々減っていく。コンピュータ業界ではデータを並べ
る時の形式のひとつで、非常に大きなシェアを持つあるCPUメーカー
はリトルエンディアンを好むという。バイトオーダー参照
</p>
</dd>
<dt>例外</dt>
<dt>Exception</dt>
<dd>
<p>
例外的な状況で発生するもの。例外が発生すると
begin の rescue 節を使って明示的に捕捉されない限り、
呼び出し階層を遡ってプログラム(thread)の実行は中断される。例外の
おかげでRubyプログラムはほとんどの場合例外的な状況についていちいち
チェックせずにすむ。例外の発生した場所の情報は <a href="../method/-kernel/v/=40.html">$@</a> に、
例外そのものに関する情報は <a href="../method/-kernel/v/=21.html">$!</a> に格納されている。
</p>
</dd>
<dt>レシーバ</dt>
<dt>Receiver</dt>
<dd>
<p>
メソッドの実行主体。メソッド呼び出し式の`.'の左
側にあるもの。メソッド内では
self で参照できる。レシーバのインスタンス変数は
@変数名という形式でアクセスできる。
</p>
</dd>
<dt>連想配列</dt>
<dt>Associative Array</dt>
<dd>
<p>
ハッシュの別名。ハッシュが任意のキーから
値を取り出すことができるので、「連想」と、またハッシュは添字
が数字でない配列とみなすことができるので「配列」と呼ぶらしい。
昔々は連想配列(連想記憶と呼ばれていた)はハードウェアによって
実現されるものだと考えられていたが、計算速度の向上や適切なア
ルゴリズムの発見(「ハッシュ表」と呼ぶ。ハッシュの語源)により
ソフトウェアのみによって実現されるようになった。
</p>
</dd>
<dt>ローカル変数</dt>
<dt>Local Variable</dt>
<dd>
<p>
ある範囲内でのみ参照可能な変数。その範囲をスコープと呼ぶ。
Rubyのスコープは
</p>
<p>
* プログラム全体
</p>
<p>
* クラス・モジュール定義
</p>
<p>
* メソッド定義
</p>
<p>
* ブロック
</p>
<p>
で、ブロックだけは外側のスコープのローカル変数もアクセスでき
る。ローカル変数の有効範囲はスコープでの最初の代入が現れた場
所からスコープの終りまでである。有効範囲は静的に決まり、実際
に実行されるかどうかは関係ない。
</p>
</dd>
</dl>
<h2 >わ</h2>
<h2 >Symbol</h2>


<div id="footer">
  <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">
    <img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/88x31.png" />
  </a>
</div>
</body>
</html>
